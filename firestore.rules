/**
 * @fileoverview Firestore Security Rules for the PULSE disaster alert system.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user profiles and alerts, while allowing more permissive (but still controlled) access to disaster event data. Data validation is relaxed to allow for rapid prototyping, focusing instead on secure authorization.
 *
 * Data Structure:
 * - /users/{userId}: User profiles, accessible only by the authenticated user with matching UID.
 * - /users/{userId}/alerts/{alertId}: Alerts specific to a user, accessible only by the user.
 * - /disasterEvents/{disasterEventId}: Disaster event information, potentially readable by specific service accounts or admin users.
 * - /disasterEvents/{disasterEventId}/insights/{insightId}: AI-generated insights related to a disaster event, inheriting the same access control as disaster events.
 *
 * Key Security Decisions:
 * - User profiles and alerts are strictly owned by the authenticated user, enforced through path-based rules.
 * - Disaster event data can be read by anyone. Write access is denied to all authenticated users. It should be provisioned via a service account.
 * - Data validation is minimal to support prototyping. The rules primarily focus on authorization.
 *
 * Denormalization for Authorization:
 * - Alerts stored under /users/{userId}/alerts denormalize relevant disaster event data to avoid costly `get()` calls in security rules. This allows rules to be based solely on the alert document and the user's ID.
 *
 * Structural Segregation:
 * - User profiles and disaster events are stored in separate top-level collections to enforce different security postures.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if the user is signed in
    function isSignedIn() {
      return request.auth != null;
    }

    // Helper function to check if the authenticated user ID matches the requested user ID.
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    // Helper function to check if the authenticated user is the existing owner of a document.
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Secures user profiles, allowing only the authenticated user to access their own profile.
     * @path /users/{userId}
     * @allow (create) User with UID 'user123' creates a profile at /users/user123.
     * @deny (create) User with UID 'user456' tries to create a profile at /users/user123.
     * @allow (get) User with UID 'user123' reads their profile at /users/user123.
     * @deny (get) User with UID 'user456' tries to read the profile at /users/user123.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      // Allow the user to create their own profile if the userId matches their auth UID.
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == userId;

      // Allow read access only to the owner.
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;

      // Allow updates only to the owner, enforcing immutability of the userId.
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;

      // Allow delete only to the owner.
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secures alerts under user profiles, allowing only the authenticated user to access their own alerts.
     * @path /users/{userId}/alerts/{alertId}
     * @allow (create) User with UID 'user123' creates an alert at /users/user123/alerts/alert456.
     * @deny (create) User with UID 'user456' tries to create an alert at /users/user123/alerts/alert456.
     * @allow (get) User with UID 'user123' reads their alert at /users/user123/alerts/alert456.
     * @deny (get) User with UID 'user456' tries to read the alert at /users/user123/alerts/alert456.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/alerts/{alertId} {
      // Allow creating an alert if the user is signed in and is the owner.
      allow create: if isSignedIn() && isOwner(userId);

      // Allow read access only to the owner.
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);

      // Allow updates only to the owner.
      allow update: if isExistingOwner(userId);

      // Allow delete only to the owner.
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secures disaster events, allowing public read access but restricting write access.
     * @path /disasterEvents/{disasterEventId}
     * @allow (get) Any user can read disaster event data.
     * @deny (create) Any authenticated user tries to create a disaster event.
     * @principle Allows public read access but restricts write access to authorized sources only.
     */
    match /disasterEvents/{disasterEventId} {
      // Allow public read access.
      allow get, list: if true;

      // Prevent all authenticated users from writing. Writes must be performed by backend only
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Secures AI-generated insights for disaster events, inheriting the same access control as disaster events.
     * @path /disasterEvents/{disasterEventId}/insights/{insightId}
     * @allow (get) Any user can read insight data.
     * @deny (create) Any authenticated user tries to create an insight.
     * @principle Inherits access control from the parent disaster event.
     */
    match /disasterEvents/{disasterEventId}/insights/{insightId} {
      // Allow public read access.
      allow get, list: if true;

      // Prevent all authenticated users from writing. Writes must be performed by backend only
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}